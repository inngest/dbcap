package replicator

import (
	"fmt"

	"github.com/jackc/pglogrepl"
)

type Decoder interface {
	Decode(in []byte) (any, error)
	ReplicationPluginArgs() []string
}

type v1LogicalDecoder struct{}

func (v1LogicalDecoder) ReplicationPluginArgs() []string {
	// https://www.postgresql.org/docs/current/protocol-logical-replication.html#PROTOCOL-LOGICAL-REPLICATION-PARAMS
	//
	// "Proto_version '2'" with "streaming 'true' streams transactions as they're progressing.
	// This is ideal for keeping the WAL buffer on disk low, but prevents Inngest working
	// properly:  we send events as the stream is received, and with streaming we instead need
	// to buffer events and send them when the transaction commits.
	//
	// Version 1 only sends DML entries when the transaction commits, ensuring that any event
	// generated by Inngest is for a committed transaction.
	return []string{
		"proto_version '1'",
		fmt.Sprintf("publication_names '%s'", PublicationName),
		"messages 'true'",
	}
}

func (v1LogicalDecoder) Decode(in []byte) (any, error) {

	msgType := pglogrepl.MessageType(in[0])
	switch msgType {
	case pglogrepl.MessageTypeBegin, pglogrepl.MessageTypeCommit:
		// These can use the pglogrepl types, as they're good enough.
		m, err := pglogrepl.Parse(in)
		if err != nil {
			return nil, fmt.Errorf("error parsing transaction begin/commit: %w", err)
		}
		return m, nil
	case pglogrepl.MessageTypeInsert, pglogrepl.MessageTypeDelete, pglogrepl.MessageTypeUpdate:
		// TODO: Parse changes - Inserts, Deletes, Updates
		return parseDataChange(in)
	default:
		// Parse truncates, relations, other messages
	}

	fmt.Println(string(in[0]))
	pglogrepl.Parse(in)
	return nil, nil
}

func parseDataChange(in []byte) (any, error) {
	reader := NewBytesReader(in)
	op, err := reader.Byte()
	if err != nil {
		return nil, err
	}
	rel, err := reader.Uint32()
	if err != nil {
		return nil, err
	}

	kind, err := reader.Byte()

	fmt.Println("")
	fmt.Println("")
	fmt.Printf("OP: %s\n", string(op))
	fmt.Printf("REL: %#v\n", rel)
	fmt.Printf("KIND: %s\n", string(kind))

	if kind != 'N' {
		// UPDATE
		// old, err := p.readTuple(reader)
		// if Op == 'U' {
		// 	kind, err = reader.Byte()
		// }
	}
	if kind == 'N' {
		// INSERT
		// m.New, err = p.readTuple(reader)
	}

	return nil, nil
}
